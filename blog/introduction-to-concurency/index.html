<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="light dark" name=color-scheme><title>Introduction to concurrency</title><meta content="<p>In this series of article we will go through about concurrency(mainly focusing on threads) and synchronization by various methods like locks atomics and etc.</p>
" name=description><link href=/img/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/img/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/img/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=https://fonts.googleapis.com rel=preconnect><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Signika&display=swap" rel=stylesheet><link href=/main.css rel=stylesheet><body class=post><script>if(localStorage.getItem('theme')=='dark')document.body.classList.add('dark')</script><header class=blur><div id=wrapper><nav><a href=/>hardfau18</a><span class=separator>::</span><a href=/blog>blog</a></nav><div id=btns><a aria-label="rss feed" href=/blog/feed.xml><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M3 17C5.20914 17 7 18.7909 7 21H3V17ZM3 10C9.07513 10 14 14.9249 14 21H12C12 16.0294 7.97056 12 3 12V10ZM3 3C12.9411 3 21 11.0589 21 21H19C19 12.1634 11.8366 5 3 5V3Z" fill=currentColor></path></svg></a><button aria-label="theme switch" data-moon-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill="currentColor"></path></svg>' data-sun-icon='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill="currentColor"></path></svg>' id=theme-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill=currentColor></path></svg></button><button aria-label="table of content" id=toc-toggle><svg viewbox="0 0 24 24" height=24 width=24 xmlns=http://www.w3.org/2000/svg><path d="M3 4H21V6H3V4ZM3 11H15V13H3V11ZM3 18H21V20H3V18Z" fill=currentColor></path></svg></button></div></div></header><div id=post-wrapper><div id=blank></div><main><div id=top></div><article><h1>Introduction to concurrency</h1><div id=post-info><div id=date><span id=publish>2023-04-15</span></div><div id=tags><a href=https://hardfau18.github.io/tags/multithreading># multithreading</a><a href=https://hardfau18.github.io/tags/locks># locks</a><a href=https://hardfau18.github.io/tags/concurrency># concurrency</a><a href=https://hardfau18.github.io/tags/datasharing># datasharing</a><a href=https://hardfau18.github.io/tags/threads># threads</a></div></div><p>In this series of article we will go through about concurrency(mainly focusing on threads) and synchronization by various methods like locks atomics and etc.</p><span id=continue-reading></span><p>Who am i? I am a embedded developer (mostly working in systems programming). At the time of writing this article I been doing systems programming for 2 years and this will be my first article so constructive criticism is welcome.<h2 id=counting-prime-numbers>Counting Prime Numbers<a aria-label="Anchor link for: counting-prime-numbers" class=zola-anchor href=#counting-prime-numbers>#</a></h2><p>Let us start with a simple example calculating number of prime numbers in the range of 2 to given number<pre class=language-c data-lang=c data-linenos style=background:#2b303b;color:#6c7079><code class=language-c data-lang=c><table><tbody><tr><td>1<td><span style=color:#cd74e8>#include </span><span style=color:#9acc76>&LTstdbool.h>
</span><tr><td>2<td><span style=color:#cd74e8>#include </span><span style=color:#9acc76>&LTstdint.h>
</span><tr><td>3<td><span style=color:#cd74e8>#include </span><span style=color:#9acc76>&LTstdio.h>
</span><tr><td>4<td><span style=color:#abb2bf>
</span><tr><td>5<td><span style=color:#cd74e8>bool __attribute__</span><span style=color:#abb2bf>((noinline, optimize(</span><span style=color:#db9d63>0</span><span style=color:#abb2bf>))) </span><span style=color:#5cb3fa>is_prime</span><span style=color:#abb2bf>(intmax_t </span><span style=color:#eb6772>num</span><span style=color:#abb2bf>) {
</span><tr><td>6<td><span style=color:#abb2bf>    </span><span style=color:#cd74e8>for </span><span style=color:#abb2bf>(intmax_t i </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>2</span><span style=color:#abb2bf>; i </span><span style=color:#adb7c9><= </span><span style=color:#abb2bf>(num </span><span style=color:#adb7c9>/ </span><span style=color:#db9d63>2</span><span style=color:#abb2bf>); i</span><span style=color:#adb7c9>++</span><span style=color:#abb2bf>) {
</span><tr><td>7<td><span style=color:#abb2bf>        </span><span style=color:#cd74e8>if </span><span style=color:#abb2bf>(num </span><span style=color:#adb7c9>%</span><span style=color:#abb2bf> i </span><span style=color:#adb7c9>== </span><span style=color:#db9d63>0</span><span style=color:#abb2bf>) {
</span><tr><td>8<td><span style=color:#abb2bf>            </span><span style=color:#cd74e8>return </span><span style=color:#db9d63>false</span><span style=color:#abb2bf>;
</span><tr><td>9<td><span style=color:#abb2bf>        }
</span><tr><td>10<td><span style=color:#abb2bf>    }
</span><tr><td>11<td><span style=color:#abb2bf>    </span><span style=color:#cd74e8>return </span><span style=color:#db9d63>true</span><span style=color:#abb2bf>;
</span><tr><td>12<td><span style=color:#abb2bf>}
</span><tr><td>13<td><span style=color:#abb2bf>
</span><tr><td>14<td><span style=color:#abb2bf>intmax_t </span><span style=color:#cd74e8>__attribute__</span><span style=color:#abb2bf>((noinline, optimize(</span><span style=color:#db9d63>0</span><span style=color:#abb2bf>))) </span><span style=color:#5cb3fa>count_prime</span><span style=color:#abb2bf>(intmax_t </span><span style=color:#eb6772>num</span><span style=color:#abb2bf>) {
</span><tr><td>15<td><span style=color:#abb2bf>    intmax_t ret </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>0</span><span style=color:#abb2bf>;
</span><tr><td>16<td><span style=color:#abb2bf>    </span><span style=color:#cd74e8>for </span><span style=color:#abb2bf>(intmax_t i </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>2</span><span style=color:#abb2bf>; i </span><span style=color:#adb7c9><</span><span style=color:#abb2bf> num; i</span><span style=color:#adb7c9>++</span><span style=color:#abb2bf>) {
</span><tr><td>17<td><span style=color:#abb2bf>        </span><span style=color:#cd74e8>if </span><span style=color:#abb2bf>(</span><span style=color:#eb6772>is_prime</span><span style=color:#abb2bf>(i))
</span><tr><td>18<td><span style=color:#abb2bf>            ret</span><span style=color:#adb7c9>++</span><span style=color:#abb2bf>;
</span><tr><td>19<td><span style=color:#abb2bf>    }
</span><tr><td>20<td><span style=color:#abb2bf>    </span><span style=color:#cd74e8>return</span><span style=color:#abb2bf> ret;
</span><tr><td>21<td><span style=color:#abb2bf>}
</span><tr><td>22<td><span style=color:#abb2bf>
</span><tr><td>23<td><span style=color:#cd74e8>int </span><span style=color:#5cb3fa>main</span><span style=color:#abb2bf>() {
</span><tr><td>24<td><span style=color:#abb2bf>    intmax_t N </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>10</span><span style=color:#abb2bf>;
</span><tr><td>25<td><span style=color:#abb2bf>    </span><span style=color:#5ebfcc>printf</span><span style=color:#abb2bf>(</span><span style=color:#9acc76>"number of primes of </span><span style=color:#db9d63>%ld</span><span style=color:#9acc76> is </span><span style=color:#db9d63>%ld</span><span style=color:#5ebfcc>\n</span><span style=color:#9acc76>"</span><span style=color:#abb2bf>, N, </span><span style=color:#eb6772>count_prime</span><span style=color:#abb2bf>(N));
</span><tr><td>26<td><span style=color:#abb2bf>}
</span></table></code></pre><p>Now if we compile this and run then we get the expected output.<br><blockquote class="callout tip"><div class=icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M9.97308 18H11V13H13V18H14.0269C14.1589 16.7984 14.7721 15.8065 15.7676 14.7226C15.8797 14.6006 16.5988 13.8564 16.6841 13.7501C17.5318 12.6931 18 11.385 18 10C18 6.68629 15.3137 4 12 4C8.68629 4 6 6.68629 6 10C6 11.3843 6.46774 12.6917 7.31462 13.7484C7.40004 13.855 8.12081 14.6012 8.23154 14.7218C9.22766 15.8064 9.84103 16.7984 9.97308 18ZM10 20V21H14V20H10ZM5.75395 14.9992C4.65645 13.6297 4 11.8915 4 10C4 5.58172 7.58172 2 12 2C16.4183 2 20 5.58172 20 10C20 11.8925 19.3428 13.6315 18.2443 15.0014C17.624 15.7748 16 17 16 18.5V21C16 22.1046 15.1046 23 14 23H10C8.89543 23 8 22.1046 8 21V18.5C8 17 6.37458 15.7736 5.75395 14.9992Z" fill=currentColor></path></svg></div><div class=content><p>You can find this code in <a rel="nofollow noreferrer" href=https://github.com/hardfau18/blog-examples/tree/main/concurrency>this repo</a></div></blockquote><pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>gcc -o</span><span style=color:#abb2bf> main.elf main.c</span><span style=color:#eb6772> -g3
</span><span style=color:#eb6772>./main.elf
</span><span style=color:#eb6772>number</span><span style=color:#abb2bf> of primes of 10 is 4
</span></code></pre><p>That's correct from 2 to 10 we have 2,3,5 and 7.<br><blockquote class="callout note"><div class=icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22ZM12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20ZM11 7H13V9H11V7ZM11 11H13V17H11V11Z" fill=currentColor></path></svg></div><div class=content><p>we will not be using any compiler optimizations intentionally(that can alter benchmarking results).</div></blockquote><p>That's great, now lets try with timings and with even bigger number. Lets try with <code>N = 200000</code>.<pre class=language-bash data-lang=bash style=background:#2b303b;color:#6c7079><code class=language-bash data-lang=bash><span style=color:#eb6772>hyperfine --show-output</span><span style=color:#abb2bf> ./main.elf
</span><span style=color:#eb6772>Benchmark</span><span style=color:#abb2bf> 1: ./main.elf
</span><span style=color:#eb6772>number</span><span style=color:#abb2bf> of primes of 200000 is 17984
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>Time</span><span style=color:#abb2bf> (mean Â± Ïƒ)</span><span style=color:#5ebfcc>:</span><span style=color:#abb2bf>      3.529 s Â±  0.033 s    </span><span style=color:#cd74e8>[</span><span style=color:#abb2bf>User: 3.528 s, System: 0.001 s</span><span style=color:#cd74e8>]
</span><span style=color:#abb2bf>  </span><span style=color:#eb6772>Range</span><span style=color:#abb2bf> (min â€¦ max)</span><span style=color:#5ebfcc>:</span><span style=color:#abb2bf>    3.505 s â€¦  3.595 s    10 runs
</span></code></pre><blockquote class="callout tip"><div class=icon><svg viewbox="0 0 24 24" height=20 width=20 xmlns=http://www.w3.org/2000/svg><path d="M9.97308 18H11V13H13V18H14.0269C14.1589 16.7984 14.7721 15.8065 15.7676 14.7226C15.8797 14.6006 16.5988 13.8564 16.6841 13.7501C17.5318 12.6931 18 11.385 18 10C18 6.68629 15.3137 4 12 4C8.68629 4 6 6.68629 6 10C6 11.3843 6.46774 12.6917 7.31462 13.7484C7.40004 13.855 8.12081 14.6012 8.23154 14.7218C9.22766 15.8064 9.84103 16.7984 9.97308 18ZM10 20V21H14V20H10ZM5.75395 14.9992C4.65645 13.6297 4 11.8915 4 10C4 5.58172 7.58172 2 12 2C16.4183 2 20 5.58172 20 10C20 11.8925 19.3428 13.6315 18.2443 15.0014C17.624 15.7748 16 17 16 18.5V21C16 22.1046 15.1046 23 14 23H10C8.89543 23 8 22.1046 8 21V18.5C8 17 6.37458 15.7736 5.75395 14.9992Z" fill=currentColor></path></svg></div><div class=content><p>benchmarking can be inaccurate if we just run it once and measure the time result may be inaccurate due to caching or other system condition, for this I will be using <a rel="nofollow noreferrer" href=https://github.com/sharkdp/hyperfine>hyperfine</a> a command-line benchmarking tool which does warm up, cache clearing, statistical analysis and etc.</div></blockquote><p>That takes roughly 3.5s and the result is <code>17984</code>. From now onward we will use this number as a reference to make sure that our changes didn't break the code.<p>Ok that was good but can we improve this? Since we are checking prime and that check can be independently calculated for each number we could parallelize this.<h2 id=multithreading>MultiThreading<a aria-label="Anchor link for: multithreading" class=zola-anchor href=#multithreading>#</a></h2><p>Lets modify our code and add threads.<pre class=language-c data-lang=c data-linenos style=background:#2b303b;color:#6c7079><code class=language-c data-lang=c><table><tbody><tr><td>1<td><span style=color:#cd74e8>#include </span><span style=color:#9acc76>&LTthreads.h>
</span><tr><td>2<td><span style=color:#abb2bf>
</span><tr><td>3<td><span style=color:#cd74e8>#define </span><span style=color:#abb2bf>NUM_THREADS </span><span style=color:#db9d63>10
</span><tr><td>4<td><span style=color:#abb2bf>intmax_t result </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>0</span><span style=color:#abb2bf>;
</span><tr><td>5<td><span style=color:#cd74e8>const </span><span style=color:#abb2bf>intmax_t N </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>200000</span><span style=color:#abb2bf>;
</span><tr><td>6<td><span style=color:#abb2bf>
</span><tr><td>7<td><span style=color:#adb7c9>...
</span><tr><td>8<td><span style=color:#abb2bf>
</span><tr><td>9<td><span style=color:#cd74e8>int </span><span style=color:#5cb3fa>count_prime</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>void</span><span style=color:#adb7c9>* </span><span style=color:#eb6772>arg</span><span style=color:#abb2bf>) {
</span><tr><td>10<td><span style=color:#abb2bf>    </span><span style=color:#cd74e8>long int</span><span style=color:#abb2bf> id </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>long int</span><span style=color:#abb2bf>)arg;
</span><tr><td>11<td><span style=color:#abb2bf>    </span><span style=color:#cd74e8>for </span><span style=color:#abb2bf>(intmax_t i </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> id; i </span><span style=color:#adb7c9><</span><span style=color:#abb2bf> N; i </span><span style=color:#adb7c9>+=</span><span style=color:#abb2bf> NUM_THREADS) {
</span><tr><td>12<td><span style=color:#abb2bf>        </span><span style=color:#cd74e8>if </span><span style=color:#abb2bf>(</span><span style=color:#eb6772>is_prime</span><span style=color:#abb2bf>(i))
</span><tr><td>13<td><span style=color:#abb2bf>            result</span><span style=color:#adb7c9>++</span><span style=color:#abb2bf>;
</span><tr><td>14<td><span style=color:#abb2bf>    }
</span><tr><td>15<td><span style=color:#abb2bf>    </span><span style=color:#cd74e8>return </span><span style=color:#db9d63>0</span><span style=color:#abb2bf>;
</span><tr><td>16<td><span style=color:#abb2bf>}
</span><tr><td>17<td><span style=color:#abb2bf>
</span><tr><td>18<td><span style=color:#cd74e8>int </span><span style=color:#5cb3fa>main</span><span style=color:#abb2bf>() {
</span><tr><td>19<td><span style=color:#abb2bf>    thrd_t handles[NUM_THREADS] </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>{</span><span style=color:#db9d63>0</span><span style=color:#abb2bf>};
</span><tr><td>20<td><span style=color:#abb2bf>    </span><span style=color:#cd74e8>for </span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>long int</span><span style=color:#abb2bf> i </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>0</span><span style=color:#abb2bf>; i </span><span style=color:#adb7c9><</span><span style=color:#abb2bf> NUM_THREADS; i</span><span style=color:#adb7c9>++</span><span style=color:#abb2bf>) {
</span><tr><td>21<td><span style=color:#abb2bf>        </span><span style=color:#eb6772>thrd_create</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>handles[i], count_prime, (</span><span style=color:#cd74e8>void</span><span style=color:#adb7c9>*</span><span style=color:#abb2bf>)i);
</span><tr><td>22<td><span style=color:#abb2bf>    }
</span><tr><td>23<td><span style=color:#abb2bf>    </span><span style=color:#cd74e8>for </span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>long int</span><span style=color:#abb2bf> i </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>0</span><span style=color:#abb2bf>; i </span><span style=color:#adb7c9><</span><span style=color:#abb2bf> NUM_THREADS; i</span><span style=color:#adb7c9>++</span><span style=color:#abb2bf>) {
</span><tr><td>24<td><span style=color:#abb2bf>        </span><span style=color:#eb6772>thrd_join</span><span style=color:#abb2bf>(handles[i], </span><span style=color:#db9d63>NULL</span><span style=color:#abb2bf>);
</span><tr><td>25<td><span style=color:#abb2bf>    }
</span><tr><td>26<td><span style=color:#abb2bf>    </span><span style=color:#5ebfcc>printf</span><span style=color:#abb2bf>(</span><span style=color:#9acc76>"number of primes of </span><span style=color:#db9d63>%ld</span><span style=color:#9acc76> is </span><span style=color:#db9d63>%ld</span><span style=color:#5ebfcc>\n</span><span style=color:#9acc76>"</span><span style=color:#abb2bf>, N, result);
</span><tr><td>27<td><span style=color:#abb2bf>}
</span></table></code></pre><p>in main we create 10 threads and in each thread we call <code>count_prime</code>. We divide the whole number range into equally for each thread and in each thread we count the number of primes in its range and increment result. Then we wait for all the threads and check the results.<br> Lets do benchmark on this<pre style=background:#2b303b;color:#6c7079><code><span style=color:#abb2bf>Benchmark 1: ./main.elf
</span><span style=color:#abb2bf>  Time (mean Â± Ïƒ):      1.104 s Â±  0.021 s    [User: 4.323 s, System: 0.001 s]
</span><span style=color:#abb2bf>  Range (min â€¦ max):    1.074 s â€¦  1.147 s    10 runs
</span></code></pre><p>That's great we made our code ~3 times fasterðŸ˜ƒ. Parallelism is wonderful and that's done.<p>Is it? Lets check the output.<pre style=background:#2b303b;color:#6c7079><code><span style=color:#abb2bf>./main.elf
</span><span style=color:#abb2bf>number of primes of 200000 is 17966
</span></code></pre><p>That's not what we expected :(. If you have noticed, you might be say that <code>result</code> should not be global and it should not be accessed by all the threads. Then you are correct. This is due to <strong>Data race</strong> or <strong>Race condition</strong>.<h2 id=data-races-and-race-condition>Data races and race condition<a aria-label="Anchor link for: data-races-and-race-condition" class=zola-anchor href=#data-races-and-race-condition>#</a></h2><p><strong>Data race</strong> occurs when 2 or more threads tries to read and modify a shared location and here all the threads are writing to globally shared <code>result</code> variable.<br> Lets take an example where 2 threads <strong>A</strong> and <strong>B</strong> are adding some value to <code>result</code> with initial value of 10.<p><figure><img alt=datarace-example-img src=/blog/concurrency-datarace_example.png><figcaption>example condition of datarace</figcaption></figure> As per above <ol><li>In step 1 <strong>A</strong> reads <code>result</code> as 10 for modification.<li>Now <strong>A</strong> adds 5 to its copy of <code>result</code>.<li>In step 3 <strong>B</strong> also reads <code>result</code> as 10, and <strong>A</strong> haven't yet committed the changes.<li><strong>B</strong> adds 8 to its local <code>result</code>.<li><strong>A</strong> writes to the <code>result</code> as 15.<li><strong>B</strong> writes to the <code>result</code> as 18.</ol><p>Thus at the end result is 18. But that's not what we expected, we expected to be like this.<figure><img alt=expected-behaviour-img src=/blog/concurrency-expected_behaviour.png><figcaption>Actual expectation</figcaption></figure> where <strong>A</strong> reads the <code>result</code> and modifies and writes back, after that <strong>B</strong> should have operated on <code>result</code>. A section/timeframe in which a thread accesses a shared data is called as <strong>critical section</strong>. In this <strong>critical section</strong> only one thread is allowed to enter. For more information check this <a rel="nofollow noreferrer" href=https://en.wikipedia.org/wiki/Race_condition#In_software>wiki article</a><h2 id=is-it-that-bad>Is it that bad?<a aria-label="Anchor link for: is-it-that-bad" class=zola-anchor href=#is-it-that-bad>#</a></h2><p>Looks like its just a calculation error, It should be ok right?<p><strong>No</strong> computers are meant to be right and accurate, These kind of issues can cause <strong>UB</strong>(undefined behavior). Using this concept exploits like <a rel="nofollow noreferrer" href=https://en.wikipedia.org/wiki/Dirty_cow>Dirty Cow</a>, which can best case crash the running program to giving full access to the given system.<h2 id=solution>Solution<a aria-label="Anchor link for: solution" class=zola-anchor href=#solution>#</a></h2><p>So how do we resolve this? You might have learned that for these kind of situation we can use <strong>locks</strong>. When we say locks there are many kinds of locks but in this situation we will use <strong>Mutexes</strong> which allows us to access a shared region mutably during a <strong>critical section</strong>. When we lock a mutex we get ownership for the given critical section and no other thread can enter while we hold the lock ( or at least should not read/write the shared data). In early days pthread library used to provide mutexes, but after c11 we have mutexes in stdlib. Lets use that<pre class=language-c data-lang=c style=background:#2b303b;color:#6c7079><code class=language-c data-lang=c><span style=color:#adb7c9>...
</span><span style=color:#cd74e8>const </span><span style=color:#abb2bf>intmax_t N </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>200000</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>mtx_t lock;
</span><span style=color:#adb7c9>...
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>int </span><span style=color:#5cb3fa>count_prime</span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>void</span><span style=color:#adb7c9>* </span><span style=color:#eb6772>arg</span><span style=color:#abb2bf>) {
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>long int</span><span style=color:#abb2bf> id </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>long int</span><span style=color:#abb2bf>)arg;
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>for </span><span style=color:#abb2bf>(intmax_t i </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>2 </span><span style=color:#adb7c9>+</span><span style=color:#abb2bf> id; i </span><span style=color:#adb7c9><</span><span style=color:#abb2bf> N; i </span><span style=color:#adb7c9>+=</span><span style=color:#abb2bf> NUM_THREADS) {
</span><span style=color:#abb2bf>        </span><span style=color:#cd74e8>if </span><span style=color:#abb2bf>(</span><span style=color:#eb6772>is_prime</span><span style=color:#abb2bf>(i)){
</span><span style=color:#abb2bf>            </span><span style=color:#eb6772>mtx_lock</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>lock);
</span><span style=color:#abb2bf>            result</span><span style=color:#adb7c9>++</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>            </span><span style=color:#eb6772>mtx_unlock</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>lock);
</span><span style=color:#abb2bf>        }
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>return </span><span style=color:#db9d63>0</span><span style=color:#abb2bf>;
</span><span style=color:#abb2bf>}
</span><span style=color:#abb2bf>
</span><span style=color:#cd74e8>int </span><span style=color:#5cb3fa>main</span><span style=color:#abb2bf>() {
</span><span style=color:#abb2bf>    thrd_t handles[NUM_THREADS] </span><span style=color:#adb7c9>= </span><span style=color:#abb2bf>{</span><span style=color:#db9d63>0</span><span style=color:#abb2bf>};
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>mtx_init</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>lock, mtx_plain);
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>for </span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>long int</span><span style=color:#abb2bf> i </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>0</span><span style=color:#abb2bf>; i </span><span style=color:#adb7c9><</span><span style=color:#abb2bf> NUM_THREADS; i</span><span style=color:#adb7c9>++</span><span style=color:#abb2bf>) {
</span><span style=color:#abb2bf>        </span><span style=color:#eb6772>thrd_create</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>handles[i], count_prime, (</span><span style=color:#cd74e8>void</span><span style=color:#adb7c9>*</span><span style=color:#abb2bf>)i);
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>    </span><span style=color:#cd74e8>for </span><span style=color:#abb2bf>(</span><span style=color:#cd74e8>long int</span><span style=color:#abb2bf> i </span><span style=color:#adb7c9>= </span><span style=color:#db9d63>0</span><span style=color:#abb2bf>; i </span><span style=color:#adb7c9><</span><span style=color:#abb2bf> NUM_THREADS; i</span><span style=color:#adb7c9>++</span><span style=color:#abb2bf>) {
</span><span style=color:#abb2bf>        </span><span style=color:#eb6772>thrd_join</span><span style=color:#abb2bf>(handles[i], </span><span style=color:#db9d63>NULL</span><span style=color:#abb2bf>);
</span><span style=color:#abb2bf>    }
</span><span style=color:#abb2bf>    </span><span style=color:#5ebfcc>printf</span><span style=color:#abb2bf>(</span><span style=color:#9acc76>"number of primes of </span><span style=color:#db9d63>%ld</span><span style=color:#9acc76> is </span><span style=color:#db9d63>%ld</span><span style=color:#5ebfcc>\n</span><span style=color:#9acc76>"</span><span style=color:#abb2bf>, N, result);
</span><span style=color:#abb2bf>    </span><span style=color:#eb6772>mtx_destroy</span><span style=color:#abb2bf>(</span><span style=color:#adb7c9>&</span><span style=color:#abb2bf>lock);
</span><span style=color:#abb2bf>}
</span></code></pre><p>Now we initialize the mutex in main and everytime before incrementing result, we lock that section so that no one can read it and modify result and unlock. Lets test our code now.<pre style=background:#2b303b;color:#6c7079><code><span style=color:#abb2bf>./main.elf list
</span><span style=color:#abb2bf>number of primes of 200000 is 17984
</span></code></pre><p>Now lets benchmark our code.<pre style=background:#2b303b;color:#6c7079><code><span style=color:#abb2bf>Benchmark 1: ./main.elf
</span><span style=color:#abb2bf>  Time (mean Â± Ïƒ):      1.092 s Â±  0.025 s    [User: 4.259 s, System: 0.004 s]
</span><span style=color:#abb2bf>  Range (min â€¦ max):    1.054 s â€¦  1.143 s    10 runs
</span></code></pre><p>Still ~3 times faster than our single threaded codeðŸ¥³. But it surprises it finishes in the same time as without locks, marginally faster than without locks but that can be error in testing <sub>(benchmarking is hardðŸ¥µ)</sub>. When we have threads and they need synchronize with each other, it slows down processing. When it comes to mutexes, they can do systemcall which introduces indeterminism, for this reason realtime applications tries to avoid mutex as much as possible.<h3 id=conclusion>Conclusion<a aria-label="Anchor link for: conclusion" class=zola-anchor href=#conclusion>#</a></h3><p>Single threaded code is safe and easy to write. But if its possible to use threads and parallelize then we could use mutexes and there are other ways for synchronization. Only thing to keep in mind that avoid sharing as much as possible, sharing is bad.<p>In our case why threaded code runs at the same speed even with locks that's for another day, we will look into upcoming articles. If you like these articles feel free to share your opinion.</article><div class=giscus></div><footer><div class=copyright><p>Â© 2023 hardfau18</div><div class=credits>Powered by <a rel="noreferrer noopener" href=https://www.getzola.org target=_blank>Zola</a> and <a rel="noreferrer noopener" href=https://github.com/isunjn/serene target=_blank>Serene</a></div></footer></main><aside class=blur><nav><ul><li><a href=#counting-prime-numbers>Counting Prime Numbers</a><li><a href=#multithreading>MultiThreading</a><li><a href=#data-races-and-race-condition>Data races and race condition</a><li><a href=#is-it-that-bad>Is it that bad?</a><li><a href=#solution>Solution</a> <ul><li><a href=#conclusion>Conclusion</a></ul></ul></nav></aside></div><script src=/js/lightense.min.js></script><script src=/js/main.js></script>